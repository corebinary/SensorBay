int get_gps_ready() {
  while (Serial2.available() > 0) {
    if (gps.encode(Serial2.read())) {
      return 1;
    }
    if (millis() > 5000 && gps.charsProcessed() < 10) {
      return 0;
    }
  }
}

float get_gps_lat() {
  if (gps.location.isValid()) {	
    return gps.location.lat();
  }
  else {
    return 0;
  }
}

unsigned long get_gps_dt_value(){
  if ((gps.date.isValid()) && (gps.time.isValid())) {
    unsigned long date_holder = gps.date.value();
    unsigned long time_holder = gps.time.value();
    unsigned long dt_value = date_holder + time_holder;
    return dt_value;
  }
  else {
    return 0;
  }
}

unsigned short get_gps_alt() {
  if (gps.location.isValid()) {
    return gps.altitude.meters();
  }
  else {
    return 0;
  }
}

float get_gps_speed() {
  if (gps.location.isValid()){
    return gps.speed.mps();
  }
  else {}
    return 0;
  }
}

unsigned short get_gps_hdop() {
  if (gps.location.isValid()) {
    return gps.hdop.value();
  }
  else {
    return 0;
  }
}

float get_compass(){
  /* Get a new sensor event */ 
  sensors_event_t event; 
  mag.getEvent(&event);
  float heading = atan2(event.magnetic.y, event.magnetic.x);

  // Once you have your heading, you must then add your 'Declination Angle', which is the 'Error' of the magnetic field in your location.
  // Find yours here: http://www.magnetic-declination.com/
  // Mine is: -13* 2' W, which is ~13 Degrees, or (which we need) 0.22 radians
  // If you cannot find your Declination, comment out these two lines, your compass will be slightly off.
  //0.17 TORONTO
  float declinationAngle = 0.17;
  heading += declinationAngle;

  // Correct for when signs are reversed.
  if(heading < 0)
    heading += 2*PI;
    
  // Check for wrap due to addition of declination.
  if(heading > 2*PI)
    heading -= 2*PI;
    
  // Convert radians to degrees for readability.
  float headingDegrees = heading * 180/M_PI; 

  return headingDegrees;
}

unsigned short get_HCSR04(int sensor) {
  long duration = 0;
  unsigned short distance = 0;

  //GPIO ASSIGNMENTS
  int trigPin[3] = {13,14,26};
  int echoPin[3] = {12,27,25};

  // Clears the trigPin
  digitalWrite(trigPin[sensor], LOW);
  delayMicroseconds(2);

  // Sets the trigPin on HIGH state for 10 micro seconds
  digitalWrite(trigPin[sensor], HIGH);
  delayMicroseconds(10);

  digitalWrite(trigPin[sensor], LOW);
  // Reads the echoPin, returns the sound wave travel time in microseconds
  duration = pulseIn(echoPin[sensor], HIGH);

  // Calculating the distance
  distance = duration * 0.034 / 2;

  return distance;    
}

